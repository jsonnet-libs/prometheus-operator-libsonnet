{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='alertmanagerConfig', url='', help='"AlertmanagerConfig configures the Prometheus Alertmanager,\\nspecifying how alerts should be grouped, inhibited and notified to external systems."'),
  '#metadata':: d.obj(help='"ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create."'),
  metadata: {
    '#withAnnotations':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotations(annotations): { metadata+: { annotations: annotations } },
    '#withAnnotationsMixin':: d.fn(help='"Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='annotations', type=d.T.object)]),
    withAnnotationsMixin(annotations): { metadata+: { annotations+: annotations } },
    '#withClusterName':: d.fn(help='"The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request."', args=[d.arg(name='clusterName', type=d.T.string)]),
    withClusterName(clusterName): { metadata+: { clusterName: clusterName } },
    '#withCreationTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='creationTimestamp', type=d.T.string)]),
    withCreationTimestamp(creationTimestamp): { metadata+: { creationTimestamp: creationTimestamp } },
    '#withDeletionGracePeriodSeconds':: d.fn(help='"Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only."', args=[d.arg(name='deletionGracePeriodSeconds', type=d.T.integer)]),
    withDeletionGracePeriodSeconds(deletionGracePeriodSeconds): { metadata+: { deletionGracePeriodSeconds: deletionGracePeriodSeconds } },
    '#withDeletionTimestamp':: d.fn(help='"Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers."', args=[d.arg(name='deletionTimestamp', type=d.T.string)]),
    withDeletionTimestamp(deletionTimestamp): { metadata+: { deletionTimestamp: deletionTimestamp } },
    '#withFinalizers':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizers(finalizers): { metadata+: { finalizers: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withFinalizersMixin':: d.fn(help='"Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='finalizers', type=d.T.array)]),
    withFinalizersMixin(finalizers): { metadata+: { finalizers+: if std.isArray(v=finalizers) then finalizers else [finalizers] } },
    '#withGenerateName':: d.fn(help='"GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.\\n\\nIf this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).\\n\\nApplied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency"', args=[d.arg(name='generateName', type=d.T.string)]),
    withGenerateName(generateName): { metadata+: { generateName: generateName } },
    '#withGeneration':: d.fn(help='"A sequence number representing a specific generation of the desired state. Populated by the system. Read-only."', args=[d.arg(name='generation', type=d.T.integer)]),
    withGeneration(generation): { metadata+: { generation: generation } },
    '#withLabels':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"', args=[d.arg(name='labels', type=d.T.object)]),
    withLabels(labels): { metadata+: { labels: labels } },
    '#withLabelsMixin':: d.fn(help='"Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='labels', type=d.T.object)]),
    withLabelsMixin(labels): { metadata+: { labels+: labels } },
    '#withName':: d.fn(help='"Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names"', args=[d.arg(name='name', type=d.T.string)]),
    withName(name): { metadata+: { name: name } },
    '#withNamespace':: d.fn(help='"Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the \\"default\\" namespace, but \\"default\\" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.\\n\\nMust be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces"', args=[d.arg(name='namespace', type=d.T.string)]),
    withNamespace(namespace): { metadata+: { namespace: namespace } },
    '#withOwnerReferences':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferences(ownerReferences): { metadata+: { ownerReferences: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withOwnerReferencesMixin':: d.fn(help='"List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='ownerReferences', type=d.T.array)]),
    withOwnerReferencesMixin(ownerReferences): { metadata+: { ownerReferences+: if std.isArray(v=ownerReferences) then ownerReferences else [ownerReferences] } },
    '#withResourceVersion':: d.fn(help='"An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.\\n\\nPopulated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency"', args=[d.arg(name='resourceVersion', type=d.T.string)]),
    withResourceVersion(resourceVersion): { metadata+: { resourceVersion: resourceVersion } },
    '#withSelfLink':: d.fn(help='"SelfLink is a URL representing this object. Populated by the system. Read-only.\\n\\nDEPRECATED Kubernetes will stop propagating this field in 1.20 release and the field is planned to be removed in 1.21 release."', args=[d.arg(name='selfLink', type=d.T.string)]),
    withSelfLink(selfLink): { metadata+: { selfLink: selfLink } },
    '#withUid':: d.fn(help='"UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.\\n\\nPopulated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids"', args=[d.arg(name='uid', type=d.T.string)]),
    withUid(uid): { metadata+: { uid: uid } },
  },
  '#new':: d.fn(help='new returns an instance of AlertmanagerConfig', args=[d.arg(name='name', type=d.T.string)]),
  new(name): {
    apiVersion: 'monitoring.coreos.com/v1alpha1',
    kind: 'AlertmanagerConfig',
  } + self.metadata.withName(name=name),
  '#spec':: d.obj(help='"spec defines the specification of AlertmanagerConfigSpec"'),
  spec: {
    '#inhibitRules':: d.obj(help="\"inhibitRules defines the list of inhibition rules. The rules will only apply to alerts matching\\nthe resource's namespace.\""),
    inhibitRules: {
      '#sourceMatch':: d.obj(help="\"sourceMatch defines matchers for which one or more alerts have to exist for the inhibition\\nto take effect. The operator enforces that the alert matches the resource's namespace.\\nThese are the \\\"trigger\\\" alerts that cause other alerts to be inhibited.\""),
      sourceMatch: {
        '#withMatchType':: d.fn(help='"matchType defines the match operation available with AlertManager >= v0.22.0.\\nTakes precedence over Regex (deprecated) if non-empty.\\nValid values: \\"=\\" (equality), \\"!=\\" (inequality), \\"=~\\" (regex match), \\"!~\\" (regex non-match)."', args=[d.arg(name='matchType', type=d.T.string)]),
        withMatchType(matchType): { matchType: matchType },
        '#withName':: d.fn(help='"name defines the label to match.\\nThis specifies which alert label should be evaluated."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withRegex':: d.fn(help='"regex defines whether to match on equality (false) or regular-expression (true).\\nDeprecated: for AlertManager >= v0.22.0, `matchType` should be used instead."', args=[d.arg(name='regex', type=d.T.boolean)]),
        withRegex(regex): { regex: regex },
        '#withValue':: d.fn(help='"value defines the label value to match.\\nThis is the expected value for the specified label."', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#targetMatch':: d.obj(help="\"targetMatch defines matchers that have to be fulfilled in the alerts to be muted.\\nThe operator enforces that the alert matches the resource's namespace.\\nWhen these conditions are met, matching alerts will be inhibited (silenced).\""),
      targetMatch: {
        '#withMatchType':: d.fn(help='"matchType defines the match operation available with AlertManager >= v0.22.0.\\nTakes precedence over Regex (deprecated) if non-empty.\\nValid values: \\"=\\" (equality), \\"!=\\" (inequality), \\"=~\\" (regex match), \\"!~\\" (regex non-match)."', args=[d.arg(name='matchType', type=d.T.string)]),
        withMatchType(matchType): { matchType: matchType },
        '#withName':: d.fn(help='"name defines the label to match.\\nThis specifies which alert label should be evaluated."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withRegex':: d.fn(help='"regex defines whether to match on equality (false) or regular-expression (true).\\nDeprecated: for AlertManager >= v0.22.0, `matchType` should be used instead."', args=[d.arg(name='regex', type=d.T.boolean)]),
        withRegex(regex): { regex: regex },
        '#withValue':: d.fn(help='"value defines the label value to match.\\nThis is the expected value for the specified label."', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#withEqual':: d.fn(help='"equal defines labels that must have an equal value in the source and target alert\\nfor the inhibition to take effect. This ensures related alerts are properly grouped."', args=[d.arg(name='equal', type=d.T.array)]),
      withEqual(equal): { equal: if std.isArray(v=equal) then equal else [equal] },
      '#withEqualMixin':: d.fn(help='"equal defines labels that must have an equal value in the source and target alert\\nfor the inhibition to take effect. This ensures related alerts are properly grouped."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='equal', type=d.T.array)]),
      withEqualMixin(equal): { equal+: if std.isArray(v=equal) then equal else [equal] },
      '#withSourceMatch':: d.fn(help="\"sourceMatch defines matchers for which one or more alerts have to exist for the inhibition\\nto take effect. The operator enforces that the alert matches the resource's namespace.\\nThese are the \\\"trigger\\\" alerts that cause other alerts to be inhibited.\"", args=[d.arg(name='sourceMatch', type=d.T.array)]),
      withSourceMatch(sourceMatch): { sourceMatch: if std.isArray(v=sourceMatch) then sourceMatch else [sourceMatch] },
      '#withSourceMatchMixin':: d.fn(help="\"sourceMatch defines matchers for which one or more alerts have to exist for the inhibition\\nto take effect. The operator enforces that the alert matches the resource's namespace.\\nThese are the \\\"trigger\\\" alerts that cause other alerts to be inhibited.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='sourceMatch', type=d.T.array)]),
      withSourceMatchMixin(sourceMatch): { sourceMatch+: if std.isArray(v=sourceMatch) then sourceMatch else [sourceMatch] },
      '#withTargetMatch':: d.fn(help="\"targetMatch defines matchers that have to be fulfilled in the alerts to be muted.\\nThe operator enforces that the alert matches the resource's namespace.\\nWhen these conditions are met, matching alerts will be inhibited (silenced).\"", args=[d.arg(name='targetMatch', type=d.T.array)]),
      withTargetMatch(targetMatch): { targetMatch: if std.isArray(v=targetMatch) then targetMatch else [targetMatch] },
      '#withTargetMatchMixin':: d.fn(help="\"targetMatch defines matchers that have to be fulfilled in the alerts to be muted.\\nThe operator enforces that the alert matches the resource's namespace.\\nWhen these conditions are met, matching alerts will be inhibited (silenced).\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='targetMatch', type=d.T.array)]),
      withTargetMatchMixin(targetMatch): { targetMatch+: if std.isArray(v=targetMatch) then targetMatch else [targetMatch] },
    },
    '#muteTimeIntervals':: d.obj(help='"muteTimeIntervals defines the list of MuteTimeInterval specifying when the routes should be muted."'),
    muteTimeIntervals: {
      '#timeIntervals':: d.obj(help='"timeIntervals defines a list of TimeInterval"'),
      timeIntervals: {
        '#daysOfMonth':: d.obj(help='"daysOfMonth defines a list of DayOfMonthRange"'),
        daysOfMonth: {
          '#withEnd':: d.fn(help='"end of the inclusive range"', args=[d.arg(name='end', type=d.T.integer)]),
          withEnd(end): { end: end },
          '#withStart':: d.fn(help='"start of the inclusive range"', args=[d.arg(name='start', type=d.T.integer)]),
          withStart(start): { start: start },
        },
        '#times':: d.obj(help='"times defines a list of TimeRange"'),
        times: {
          '#withEndTime':: d.fn(help='"endTime defines the end time in 24hr format."', args=[d.arg(name='endTime', type=d.T.string)]),
          withEndTime(endTime): { endTime: endTime },
          '#withStartTime':: d.fn(help='"startTime defines the start time in 24hr format."', args=[d.arg(name='startTime', type=d.T.string)]),
          withStartTime(startTime): { startTime: startTime },
        },
        '#withDaysOfMonth':: d.fn(help='"daysOfMonth defines a list of DayOfMonthRange"', args=[d.arg(name='daysOfMonth', type=d.T.array)]),
        withDaysOfMonth(daysOfMonth): { daysOfMonth: if std.isArray(v=daysOfMonth) then daysOfMonth else [daysOfMonth] },
        '#withDaysOfMonthMixin':: d.fn(help='"daysOfMonth defines a list of DayOfMonthRange"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='daysOfMonth', type=d.T.array)]),
        withDaysOfMonthMixin(daysOfMonth): { daysOfMonth+: if std.isArray(v=daysOfMonth) then daysOfMonth else [daysOfMonth] },
        '#withMonths':: d.fn(help='"months defines a list of MonthRange"', args=[d.arg(name='months', type=d.T.array)]),
        withMonths(months): { months: if std.isArray(v=months) then months else [months] },
        '#withMonthsMixin':: d.fn(help='"months defines a list of MonthRange"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='months', type=d.T.array)]),
        withMonthsMixin(months): { months+: if std.isArray(v=months) then months else [months] },
        '#withTimes':: d.fn(help='"times defines a list of TimeRange"', args=[d.arg(name='times', type=d.T.array)]),
        withTimes(times): { times: if std.isArray(v=times) then times else [times] },
        '#withTimesMixin':: d.fn(help='"times defines a list of TimeRange"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='times', type=d.T.array)]),
        withTimesMixin(times): { times+: if std.isArray(v=times) then times else [times] },
        '#withWeekdays':: d.fn(help='"weekdays defines a list of WeekdayRange"', args=[d.arg(name='weekdays', type=d.T.array)]),
        withWeekdays(weekdays): { weekdays: if std.isArray(v=weekdays) then weekdays else [weekdays] },
        '#withWeekdaysMixin':: d.fn(help='"weekdays defines a list of WeekdayRange"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='weekdays', type=d.T.array)]),
        withWeekdaysMixin(weekdays): { weekdays+: if std.isArray(v=weekdays) then weekdays else [weekdays] },
        '#withYears':: d.fn(help='"years defines a list of YearRange"', args=[d.arg(name='years', type=d.T.array)]),
        withYears(years): { years: if std.isArray(v=years) then years else [years] },
        '#withYearsMixin':: d.fn(help='"years defines a list of YearRange"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='years', type=d.T.array)]),
        withYearsMixin(years): { years+: if std.isArray(v=years) then years else [years] },
      },
      '#withName':: d.fn(help='"name of the time interval"', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withTimeIntervals':: d.fn(help='"timeIntervals defines a list of TimeInterval"', args=[d.arg(name='timeIntervals', type=d.T.array)]),
      withTimeIntervals(timeIntervals): { timeIntervals: if std.isArray(v=timeIntervals) then timeIntervals else [timeIntervals] },
      '#withTimeIntervalsMixin':: d.fn(help='"timeIntervals defines a list of TimeInterval"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='timeIntervals', type=d.T.array)]),
      withTimeIntervalsMixin(timeIntervals): { timeIntervals+: if std.isArray(v=timeIntervals) then timeIntervals else [timeIntervals] },
    },
    '#receivers':: d.obj(help='"receivers defines the list of receivers."'),
    receivers: {
      '#discordConfigs':: d.obj(help='"discordConfigs defines the list of Slack configurations."'),
      discordConfigs: {
        '#apiURL':: d.obj(help="\"apiURL defines the secret's key that contains the Discord webhook URL.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
        apiURL: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { apiURL+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { apiURL+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { apiURL+: { optional: optional } },
        },
        '#httpConfig':: d.obj(help='"httpConfig defines the HTTP client configuration."'),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#withAvatarURL':: d.fn(help='"avatarURL defines the avatar url of the message sender."', args=[d.arg(name='avatarURL', type=d.T.string)]),
        withAvatarURL(avatarURL): { avatarURL: avatarURL },
        '#withContent':: d.fn(help="\"content defines the template of the content's body.\"", args=[d.arg(name='content', type=d.T.string)]),
        withContent(content): { content: content },
        '#withMessage':: d.fn(help="\"message defines the template of the message's body.\"", args=[d.arg(name='message', type=d.T.string)]),
        withMessage(message): { message: message },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withTitle':: d.fn(help="\"title defines the template of the message's title.\"", args=[d.arg(name='title', type=d.T.string)]),
        withTitle(title): { title: title },
        '#withUsername':: d.fn(help='"username defines the username of the message sender."', args=[d.arg(name='username', type=d.T.string)]),
        withUsername(username): { username: username },
      },
      '#emailConfigs':: d.obj(help='"emailConfigs defines the list of Email configurations."'),
      emailConfigs: {
        '#authPassword':: d.obj(help="\"authPassword defines the secret's key that contains the password to use for authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
        authPassword: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { authPassword+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { authPassword+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { authPassword+: { optional: optional } },
        },
        '#authSecret':: d.obj(help="\"authSecret defines the secret's key that contains the CRAM-MD5 secret.\\nThis is used for CRAM-MD5 authentication mechanism.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
        authSecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { authSecret+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { authSecret+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { authSecret+: { optional: optional } },
        },
        '#headers':: d.obj(help='"headers defines additional email header key/value pairs.\\nThese override any headers previously set by the notification implementation."'),
        headers: {
          '#withKey':: d.fn(help='"key defines the key of the tuple.\\nThis is the identifier or name part of the key-value pair."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"value defines the value of the tuple.\\nThis is the data or content associated with the key."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for SMTP connections.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
        tlsConfig: {
          '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
          ca: {
            '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
            configMap: {
              '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { tlsConfig+: { ca+: { configMap+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { tlsConfig+: { ca+: { configMap+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { tlsConfig+: { ca+: { configMap+: { optional: optional } } } },
            },
            '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
            secret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { tlsConfig+: { ca+: { secret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { tlsConfig+: { ca+: { secret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { tlsConfig+: { ca+: { secret+: { optional: optional } } } },
            },
          },
          '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
          cert: {
            '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
            configMap: {
              '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { tlsConfig+: { cert+: { configMap+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { tlsConfig+: { cert+: { configMap+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { tlsConfig+: { cert+: { configMap+: { optional: optional } } } },
            },
            '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
            secret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { tlsConfig+: { cert+: { secret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { tlsConfig+: { cert+: { secret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { tlsConfig+: { cert+: { secret+: { optional: optional } } } },
            },
          },
          '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
          keySecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { tlsConfig+: { keySecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { tlsConfig+: { keySecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { tlsConfig+: { keySecret+: { optional: optional } } },
          },
          '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
          withInsecureSkipVerify(insecureSkipVerify): { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } },
          '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
          withMaxVersion(maxVersion): { tlsConfig+: { maxVersion: maxVersion } },
          '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
          withMinVersion(minVersion): { tlsConfig+: { minVersion: minVersion } },
          '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
          withServerName(serverName): { tlsConfig+: { serverName: serverName } },
        },
        '#withAuthIdentity':: d.fn(help='"authIdentity defines the identity to use for SMTP authentication.\\nThis is typically used with PLAIN authentication mechanism."', args=[d.arg(name='authIdentity', type=d.T.string)]),
        withAuthIdentity(authIdentity): { authIdentity: authIdentity },
        '#withAuthUsername':: d.fn(help='"authUsername defines the username to use for SMTP authentication.\\nThis is used for SMTP AUTH when the server requires authentication."', args=[d.arg(name='authUsername', type=d.T.string)]),
        withAuthUsername(authUsername): { authUsername: authUsername },
        '#withFrom':: d.fn(help='"from defines the sender address for email notifications.\\nThis appears as the \\"From\\" field in the email header."', args=[d.arg(name='from', type=d.T.string)]),
        withFrom(from): { from: from },
        '#withHeaders':: d.fn(help='"headers defines additional email header key/value pairs.\\nThese override any headers previously set by the notification implementation."', args=[d.arg(name='headers', type=d.T.array)]),
        withHeaders(headers): { headers: if std.isArray(v=headers) then headers else [headers] },
        '#withHeadersMixin':: d.fn(help='"headers defines additional email header key/value pairs.\\nThese override any headers previously set by the notification implementation."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='headers', type=d.T.array)]),
        withHeadersMixin(headers): { headers+: if std.isArray(v=headers) then headers else [headers] },
        '#withHello':: d.fn(help='"hello defines the hostname to identify to the SMTP server.\\nThis is used in the SMTP HELO/EHLO command during the connection handshake."', args=[d.arg(name='hello', type=d.T.string)]),
        withHello(hello): { hello: hello },
        '#withHtml':: d.fn(help='"html defines the HTML body of the email notification.\\nThis allows for rich formatting in the email content."', args=[d.arg(name='html', type=d.T.string)]),
        withHtml(html): { html: html },
        '#withRequireTLS':: d.fn(help='"requireTLS defines the SMTP TLS requirement.\\nNote that Go does not support unencrypted connections to remote SMTP endpoints."', args=[d.arg(name='requireTLS', type=d.T.boolean)]),
        withRequireTLS(requireTLS): { requireTLS: requireTLS },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withSmarthost':: d.fn(help='"smarthost defines the SMTP host and port through which emails are sent.\\nFormat should be \\"hostname:port\\", e.g. \\"smtp.example.com:587\\"."', args=[d.arg(name='smarthost', type=d.T.string)]),
        withSmarthost(smarthost): { smarthost: smarthost },
        '#withText':: d.fn(help="\"text defines the plain text body of the email notification.\\nThis provides a fallback for email clients that don't support HTML.\"", args=[d.arg(name='text', type=d.T.string)]),
        withText(text): { text: text },
        '#withTo':: d.fn(help='"to defines the email address to send notifications to.\\nThis is the recipient address for alert notifications."', args=[d.arg(name='to', type=d.T.string)]),
        withTo(to): { to: to },
      },
      '#msteamsConfigs':: d.obj(help='"msteamsConfigs defines the list of MSTeams configurations.\\nIt requires Alertmanager >= 0.26.0."'),
      msteamsConfigs: {
        '#httpConfig':: d.obj(help='"httpConfig defines the HTTP client configuration for Teams webhook requests."'),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#webhookUrl':: d.obj(help='"webhookUrl defines the MSTeams webhook URL for sending notifications.\\nThis is the incoming webhook URL configured in your Teams channel."'),
        webhookUrl: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { webhookUrl+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { webhookUrl+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { webhookUrl+: { optional: optional } },
        },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withSummary':: d.fn(help='"summary defines the message summary template for Teams notifications.\\nThis provides a brief overview that appears in Teams notification previews.\\nIt requires Alertmanager >= 0.27.0."', args=[d.arg(name='summary', type=d.T.string)]),
        withSummary(summary): { summary: summary },
        '#withText':: d.fn(help='"text defines the message body template for Teams notifications.\\nThis contains the detailed content of the Teams message."', args=[d.arg(name='text', type=d.T.string)]),
        withText(text): { text: text },
        '#withTitle':: d.fn(help='"title defines the message title template for Teams notifications.\\nThis appears as the main heading of the Teams message card."', args=[d.arg(name='title', type=d.T.string)]),
        withTitle(title): { title: title },
      },
      '#msteamsv2Configs':: d.obj(help='"msteamsv2Configs defines the list of MSTeamsV2 configurations.\\nIt requires Alertmanager >= 0.28.0."'),
      msteamsv2Configs: {
        '#httpConfig':: d.obj(help='"httpConfig defines the HTTP client configuration for Teams webhook requests."'),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#webhookURL':: d.obj(help='"webhookURL defines the MSTeams incoming webhook URL for adaptive card notifications.\\nThis webhook must support the newer adaptive cards format required by Teams flows."'),
        webhookURL: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { webhookURL+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { webhookURL+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { webhookURL+: { optional: optional } },
        },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withText':: d.fn(help='"text defines the message body template for adaptive card notifications.\\nThis contains the detailed content displayed in the Teams adaptive card format."', args=[d.arg(name='text', type=d.T.string)]),
        withText(text): { text: text },
        '#withTitle':: d.fn(help='"title defines the message title template for adaptive card notifications.\\nThis appears as the main heading in the Teams adaptive card."', args=[d.arg(name='title', type=d.T.string)]),
        withTitle(title): { title: title },
      },
      '#opsgenieConfigs':: d.obj(help='"opsgenieConfigs defines the list of OpsGenie configurations."'),
      opsgenieConfigs: {
        '#apiKey':: d.obj(help="\"apiKey defines the secret's key that contains the OpsGenie API key.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
        apiKey: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { apiKey+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { apiKey+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { apiKey+: { optional: optional } },
        },
        '#details':: d.obj(help='"details defines a set of arbitrary key/value pairs that provide further detail about the incident.\\nThese appear as additional fields in the OpsGenie alert."'),
        details: {
          '#withKey':: d.fn(help='"key defines the key of the tuple.\\nThis is the identifier or name part of the key-value pair."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"value defines the value of the tuple.\\nThis is the data or content associated with the key."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#httpConfig':: d.obj(help='"httpConfig defines the HTTP client configuration for OpsGenie API requests."'),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#responders':: d.obj(help='"responders defines the list of responders responsible for notifications.\\nThese determine who gets notified when the alert is created."'),
        responders: {
          '#withId':: d.fn(help="\"id defines the unique identifier of the responder.\\nThis corresponds to the responder's ID within OpsGenie.\"", args=[d.arg(name='id', type=d.T.string)]),
          withId(id): { id: id },
          '#withName':: d.fn(help='"name defines the display name of the responder.\\nThis is used when the responder is identified by name rather than ID."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withType':: d.fn(help='"type defines the type of responder.\\nValid values include \\"user\\", \\"team\\", \\"schedule\\", and \\"escalation\\".\\nThis determines how OpsGenie interprets the other identifier fields."', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { type: type },
          '#withUsername':: d.fn(help='"username defines the username of the responder.\\nThis is typically used for user-type responders when identifying by username."', args=[d.arg(name='username', type=d.T.string)]),
          withUsername(username): { username: username },
        },
        '#withActions':: d.fn(help='"actions defines a comma separated list of actions that will be available for the alert.\\nThese appear as action buttons in the OpsGenie interface."', args=[d.arg(name='actions', type=d.T.string)]),
        withActions(actions): { actions: actions },
        '#withApiURL':: d.fn(help='"apiURL defines the URL to send OpsGenie API requests to.\\nWhen not specified, defaults to the standard OpsGenie API endpoint."', args=[d.arg(name='apiURL', type=d.T.string)]),
        withApiURL(apiURL): { apiURL: apiURL },
        '#withDescription':: d.fn(help='"description defines the detailed description of the incident.\\nThis provides additional context beyond the message field."', args=[d.arg(name='description', type=d.T.string)]),
        withDescription(description): { description: description },
        '#withDetails':: d.fn(help='"details defines a set of arbitrary key/value pairs that provide further detail about the incident.\\nThese appear as additional fields in the OpsGenie alert."', args=[d.arg(name='details', type=d.T.array)]),
        withDetails(details): { details: if std.isArray(v=details) then details else [details] },
        '#withDetailsMixin':: d.fn(help='"details defines a set of arbitrary key/value pairs that provide further detail about the incident.\\nThese appear as additional fields in the OpsGenie alert."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='details', type=d.T.array)]),
        withDetailsMixin(details): { details+: if std.isArray(v=details) then details else [details] },
        '#withEntity':: d.fn(help='"entity defines an optional field that can be used to specify which domain alert is related to.\\nThis helps group related alerts together in OpsGenie."', args=[d.arg(name='entity', type=d.T.string)]),
        withEntity(entity): { entity: entity },
        '#withMessage':: d.fn(help='"message defines the alert text limited to 130 characters.\\nThis appears as the main alert title in OpsGenie."', args=[d.arg(name='message', type=d.T.string)]),
        withMessage(message): { message: message },
        '#withNote':: d.fn(help='"note defines an additional alert note.\\nThis provides supplementary information about the alert."', args=[d.arg(name='note', type=d.T.string)]),
        withNote(note): { note: note },
        '#withPriority':: d.fn(help='"priority defines the priority level of alert.\\nPossible values are P1, P2, P3, P4, and P5, where P1 is highest priority."', args=[d.arg(name='priority', type=d.T.string)]),
        withPriority(priority): { priority: priority },
        '#withResponders':: d.fn(help='"responders defines the list of responders responsible for notifications.\\nThese determine who gets notified when the alert is created."', args=[d.arg(name='responders', type=d.T.array)]),
        withResponders(responders): { responders: if std.isArray(v=responders) then responders else [responders] },
        '#withRespondersMixin':: d.fn(help='"responders defines the list of responders responsible for notifications.\\nThese determine who gets notified when the alert is created."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='responders', type=d.T.array)]),
        withRespondersMixin(responders): { responders+: if std.isArray(v=responders) then responders else [responders] },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withSource':: d.fn(help='"source defines the backlink to the sender of the notification.\\nThis helps identify where the alert originated from."', args=[d.arg(name='source', type=d.T.string)]),
        withSource(source): { source: source },
        '#withTags':: d.fn(help='"tags defines a comma separated list of tags attached to the notifications.\\nThese help categorize and filter alerts within OpsGenie."', args=[d.arg(name='tags', type=d.T.string)]),
        withTags(tags): { tags: tags },
        '#withUpdateAlerts':: d.fn(help='"updateAlerts defines Whether to update message and description of the alert in OpsGenie if it already exists\\nBy default, the alert is never updated in OpsGenie, the new message only appears in activity log."', args=[d.arg(name='updateAlerts', type=d.T.boolean)]),
        withUpdateAlerts(updateAlerts): { updateAlerts: updateAlerts },
      },
      '#pagerdutyConfigs':: d.obj(help='"pagerdutyConfigs defines the List of PagerDuty configurations."'),
      pagerdutyConfigs: {
        '#details':: d.obj(help='"details defines the arbitrary key/value pairs that provide further detail about the incident."'),
        details: {
          '#withKey':: d.fn(help='"key defines the key of the tuple.\\nThis is the identifier or name part of the key-value pair."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"value defines the value of the tuple.\\nThis is the data or content associated with the key."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#httpConfig':: d.obj(help='"httpConfig defines the HTTP client configuration."'),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#pagerDutyImageConfigs':: d.obj(help='"pagerDutyImageConfigs defines a list of image details to attach that provide further detail about an incident."'),
        pagerDutyImageConfigs: {
          '#withAlt':: d.fn(help='"alt is the optional alternative text for the image."', args=[d.arg(name='alt', type=d.T.string)]),
          withAlt(alt): { alt: alt },
          '#withHref':: d.fn(help='"href defines the optional URL; makes the image a clickable link."', args=[d.arg(name='href', type=d.T.string)]),
          withHref(href): { href: href },
          '#withSrc':: d.fn(help='"src of the image being attached to the incident"', args=[d.arg(name='src', type=d.T.string)]),
          withSrc(src): { src: src },
        },
        '#pagerDutyLinkConfigs':: d.obj(help='"pagerDutyLinkConfigs defines a list of link details to attach that provide further detail about an incident."'),
        pagerDutyLinkConfigs: {
          '#withAlt':: d.fn(help="\"alt defines the text that describes the purpose of the link, and can be used as the link's text.\"", args=[d.arg(name='alt', type=d.T.string)]),
          withAlt(alt): { alt: alt },
          '#withHref':: d.fn(help='"href defines the URL of the link to be attached"', args=[d.arg(name='href', type=d.T.string)]),
          withHref(href): { href: href },
        },
        '#routingKey':: d.obj(help="\"routingKey defines the secret's key that contains the PagerDuty integration key (when using\\nEvents API v2). Either this field or `serviceKey` needs to be defined.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
        routingKey: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { routingKey+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { routingKey+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { routingKey+: { optional: optional } },
        },
        '#serviceKey':: d.obj(help="\"serviceKey defines the secret's key that contains the PagerDuty service key (when using\\nintegration type \\\"Prometheus\\\"). Either this field or `routingKey` needs to\\nbe defined.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
        serviceKey: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { serviceKey+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { serviceKey+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { serviceKey+: { optional: optional } },
        },
        '#withClass':: d.fn(help='"class defines the class/type of the event."', args=[d.arg(name='class', type=d.T.string)]),
        withClass(class): { class: class },
        '#withClient':: d.fn(help='"client defines the client identification."', args=[d.arg(name='client', type=d.T.string)]),
        withClient(client): { client: client },
        '#withClientURL':: d.fn(help='"clientURL defines the backlink to the sender of notification."', args=[d.arg(name='clientURL', type=d.T.string)]),
        withClientURL(clientURL): { clientURL: clientURL },
        '#withComponent':: d.fn(help='"component defines the part or component of the affected system that is broken."', args=[d.arg(name='component', type=d.T.string)]),
        withComponent(component): { component: component },
        '#withDescription':: d.fn(help='"description of the incident."', args=[d.arg(name='description', type=d.T.string)]),
        withDescription(description): { description: description },
        '#withDetails':: d.fn(help='"details defines the arbitrary key/value pairs that provide further detail about the incident."', args=[d.arg(name='details', type=d.T.array)]),
        withDetails(details): { details: if std.isArray(v=details) then details else [details] },
        '#withDetailsMixin':: d.fn(help='"details defines the arbitrary key/value pairs that provide further detail about the incident."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='details', type=d.T.array)]),
        withDetailsMixin(details): { details+: if std.isArray(v=details) then details else [details] },
        '#withGroup':: d.fn(help='"group defines a cluster or grouping of sources."', args=[d.arg(name='group', type=d.T.string)]),
        withGroup(group): { group: group },
        '#withPagerDutyImageConfigs':: d.fn(help='"pagerDutyImageConfigs defines a list of image details to attach that provide further detail about an incident."', args=[d.arg(name='pagerDutyImageConfigs', type=d.T.array)]),
        withPagerDutyImageConfigs(pagerDutyImageConfigs): { pagerDutyImageConfigs: if std.isArray(v=pagerDutyImageConfigs) then pagerDutyImageConfigs else [pagerDutyImageConfigs] },
        '#withPagerDutyImageConfigsMixin':: d.fn(help='"pagerDutyImageConfigs defines a list of image details to attach that provide further detail about an incident."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='pagerDutyImageConfigs', type=d.T.array)]),
        withPagerDutyImageConfigsMixin(pagerDutyImageConfigs): { pagerDutyImageConfigs+: if std.isArray(v=pagerDutyImageConfigs) then pagerDutyImageConfigs else [pagerDutyImageConfigs] },
        '#withPagerDutyLinkConfigs':: d.fn(help='"pagerDutyLinkConfigs defines a list of link details to attach that provide further detail about an incident."', args=[d.arg(name='pagerDutyLinkConfigs', type=d.T.array)]),
        withPagerDutyLinkConfigs(pagerDutyLinkConfigs): { pagerDutyLinkConfigs: if std.isArray(v=pagerDutyLinkConfigs) then pagerDutyLinkConfigs else [pagerDutyLinkConfigs] },
        '#withPagerDutyLinkConfigsMixin':: d.fn(help='"pagerDutyLinkConfigs defines a list of link details to attach that provide further detail about an incident."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='pagerDutyLinkConfigs', type=d.T.array)]),
        withPagerDutyLinkConfigsMixin(pagerDutyLinkConfigs): { pagerDutyLinkConfigs+: if std.isArray(v=pagerDutyLinkConfigs) then pagerDutyLinkConfigs else [pagerDutyLinkConfigs] },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withSeverity':: d.fn(help='"severity of the incident."', args=[d.arg(name='severity', type=d.T.string)]),
        withSeverity(severity): { severity: severity },
        '#withSource':: d.fn(help='"source defines the unique location of the affected system."', args=[d.arg(name='source', type=d.T.string)]),
        withSource(source): { source: source },
        '#withUrl':: d.fn(help='"url defines the URL to send requests to."', args=[d.arg(name='url', type=d.T.string)]),
        withUrl(url): { url: url },
      },
      '#pushoverConfigs':: d.obj(help='"pushoverConfigs defines the list of Pushover configurations."'),
      pushoverConfigs: {
        '#httpConfig':: d.obj(help='"httpConfig defines the HTTP client configuration for Pushover API requests."'),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#token':: d.obj(help="\"token defines the secret's key that contains the registered application's API token.\\nSee https://pushover.net/apps for application registration.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\\nEither `token` or `tokenFile` is required.\""),
        token: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { token+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { token+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { token+: { optional: optional } },
        },
        '#userKey':: d.obj(help="\"userKey defines the secret's key that contains the recipient user's user key.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\\nEither `userKey` or `userKeyFile` is required.\""),
        userKey: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { userKey+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { userKey+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { userKey+: { optional: optional } },
        },
        '#withDevice':: d.fn(help="\"device defines the name of a specific device to send the notification to.\\nIf not specified, the notification is sent to all user's devices.\"", args=[d.arg(name='device', type=d.T.string)]),
        withDevice(device): { device: device },
        '#withExpire':: d.fn(help='"expire defines how long your notification will continue to be retried for,\\nunless the user acknowledges the notification. Only applies to priority 2 notifications."', args=[d.arg(name='expire', type=d.T.string)]),
        withExpire(expire): { expire: expire },
        '#withHtml':: d.fn(help='"html defines whether notification message is HTML or plain text.\\nWhen true, the message can include HTML formatting tags."', args=[d.arg(name='html', type=d.T.boolean)]),
        withHtml(html): { html: html },
        '#withMessage':: d.fn(help='"message defines the notification message content.\\nThis is the main body text of the Pushover notification."', args=[d.arg(name='message', type=d.T.string)]),
        withMessage(message): { message: message },
        '#withPriority':: d.fn(help='"priority defines the notification priority level.\\nSee https://pushover.net/api#priority for valid values and behavior."', args=[d.arg(name='priority', type=d.T.string)]),
        withPriority(priority): { priority: priority },
        '#withRetry':: d.fn(help='"retry defines how often the Pushover servers will send the same notification to the user.\\nMust be at least 30 seconds. Only applies to priority 2 notifications."', args=[d.arg(name='retry', type=d.T.string)]),
        withRetry(retry): { retry: retry },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withSound':: d.fn(help="\"sound defines the name of one of the sounds supported by device clients.\\nThis overrides the user's default sound choice for this notification.\"", args=[d.arg(name='sound', type=d.T.string)]),
        withSound(sound): { sound: sound },
        '#withTitle':: d.fn(help='"title defines the notification title displayed in the Pushover message.\\nThis appears as the bold header text in the notification."', args=[d.arg(name='title', type=d.T.string)]),
        withTitle(title): { title: title },
        '#withTokenFile':: d.fn(help="\"tokenFile defines the token file that contains the registered application's API token.\\nSee https://pushover.net/apps for application registration.\\nEither `token` or `tokenFile` is required.\\nIt requires Alertmanager \u003e= v0.26.0.\"", args=[d.arg(name='tokenFile', type=d.T.string)]),
        withTokenFile(tokenFile): { tokenFile: tokenFile },
        '#withTtl':: d.fn(help='"ttl defines the time to live for the alert notification.\\nThis determines how long the notification remains active before expiring."', args=[d.arg(name='ttl', type=d.T.string)]),
        withTtl(ttl): { ttl: ttl },
        '#withUrl':: d.fn(help='"url defines a supplementary URL shown alongside the message.\\nThis creates a clickable link within the Pushover notification."', args=[d.arg(name='url', type=d.T.string)]),
        withUrl(url): { url: url },
        '#withUrlTitle':: d.fn(help='"urlTitle defines a title for the supplementary URL.\\nIf not specified, the raw URL is shown instead."', args=[d.arg(name='urlTitle', type=d.T.string)]),
        withUrlTitle(urlTitle): { urlTitle: urlTitle },
        '#withUserKeyFile':: d.fn(help="\"userKeyFile defines the user key file that contains the recipient user's user key.\\nEither `userKey` or `userKeyFile` is required.\\nIt requires Alertmanager \u003e= v0.26.0.\"", args=[d.arg(name='userKeyFile', type=d.T.string)]),
        withUserKeyFile(userKeyFile): { userKeyFile: userKeyFile },
      },
      '#rocketchatConfigs':: d.obj(help='"rocketchatConfigs defines the list of RocketChat configurations.\\nIt requires Alertmanager >= 0.28.0."'),
      rocketchatConfigs: {
        '#actions':: d.obj(help='"actions defines interactive actions to include in the message.\\nThese appear as buttons that users can click to trigger responses."'),
        actions: {
          '#withMsg':: d.fn(help='"msg defines the message to send when the button is clicked.\\nThis allows the button to post a predefined message to the channel."', args=[d.arg(name='msg', type=d.T.string)]),
          withMsg(msg): { msg: msg },
          '#withText':: d.fn(help='"text defines the button text displayed to users.\\nThis is the label that appears on the interactive button."', args=[d.arg(name='text', type=d.T.string)]),
          withText(text): { text: text },
          '#withUrl':: d.fn(help='"url defines the URL the button links to when clicked.\\nThis creates a clickable button that opens the specified URL."', args=[d.arg(name='url', type=d.T.string)]),
          withUrl(url): { url: url },
        },
        '#fields':: d.obj(help='"fields defines additional fields for the message attachment.\\nThese appear as structured key-value pairs within the message."'),
        fields: {
          '#withShort':: d.fn(help='"short defines whether this field should be a short field.\\nWhen true, the field may be displayed inline with other short fields to save space."', args=[d.arg(name='short', type=d.T.boolean)]),
          withShort(short): { short: short },
          '#withTitle':: d.fn(help='"title defines the title of this field.\\nThis appears as bold text labeling the field content."', args=[d.arg(name='title', type=d.T.string)]),
          withTitle(title): { title: title },
          '#withValue':: d.fn(help='"value defines the value of this field, displayed underneath the title.\\nThis contains the actual data or content for the field."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#httpConfig':: d.obj(help='"httpConfig defines the HTTP client configuration for RocketChat API requests."'),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#token':: d.obj(help='"token defines the sender token for RocketChat authentication.\\nThis is the personal access token or bot token used to authenticate API requests."'),
        token: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { token+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { token+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { token+: { optional: optional } },
        },
        '#tokenID':: d.obj(help='"tokenID defines the sender token ID for RocketChat authentication.\\nThis is the user ID associated with the token used for API requests."'),
        tokenID: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { tokenID+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { tokenID+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { tokenID+: { optional: optional } },
        },
        '#withActions':: d.fn(help='"actions defines interactive actions to include in the message.\\nThese appear as buttons that users can click to trigger responses."', args=[d.arg(name='actions', type=d.T.array)]),
        withActions(actions): { actions: if std.isArray(v=actions) then actions else [actions] },
        '#withActionsMixin':: d.fn(help='"actions defines interactive actions to include in the message.\\nThese appear as buttons that users can click to trigger responses."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='actions', type=d.T.array)]),
        withActionsMixin(actions): { actions+: if std.isArray(v=actions) then actions else [actions] },
        '#withApiURL':: d.fn(help='"apiURL defines the API URL for RocketChat.\\nDefaults to https://open.rocket.chat/ if not specified."', args=[d.arg(name='apiURL', type=d.T.string)]),
        withApiURL(apiURL): { apiURL: apiURL },
        '#withChannel':: d.fn(help='"channel defines the channel to send alerts to.\\nThis can be a channel name (e.g., \\"#alerts\\") or a direct message recipient."', args=[d.arg(name='channel', type=d.T.string)]),
        withChannel(channel): { channel: channel },
        '#withColor':: d.fn(help='"color defines the message color displayed in RocketChat.\\nThis appears as a colored bar alongside the message."', args=[d.arg(name='color', type=d.T.string)]),
        withColor(color): { color: color },
        '#withEmoji':: d.fn(help='"emoji defines the emoji to be displayed as an avatar.\\nIf provided, this emoji will be used instead of the default avatar or iconURL."', args=[d.arg(name='emoji', type=d.T.string)]),
        withEmoji(emoji): { emoji: emoji },
        '#withFields':: d.fn(help='"fields defines additional fields for the message attachment.\\nThese appear as structured key-value pairs within the message."', args=[d.arg(name='fields', type=d.T.array)]),
        withFields(fields): { fields: if std.isArray(v=fields) then fields else [fields] },
        '#withFieldsMixin':: d.fn(help='"fields defines additional fields for the message attachment.\\nThese appear as structured key-value pairs within the message."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='fields', type=d.T.array)]),
        withFieldsMixin(fields): { fields+: if std.isArray(v=fields) then fields else [fields] },
        '#withIconURL':: d.fn(help="\"iconURL defines the icon URL for the message avatar.\\nThis displays a custom image as the message sender's avatar.\"", args=[d.arg(name='iconURL', type=d.T.string)]),
        withIconURL(iconURL): { iconURL: iconURL },
        '#withImageURL':: d.fn(help='"imageURL defines the image URL to display within the message.\\nThis embeds an image directly in the message attachment."', args=[d.arg(name='imageURL', type=d.T.string)]),
        withImageURL(imageURL): { imageURL: imageURL },
        '#withLinkNames':: d.fn(help='"linkNames defines whether to enable automatic linking of usernames and channels.\\nWhen true, @username and #channel references become clickable links."', args=[d.arg(name='linkNames', type=d.T.boolean)]),
        withLinkNames(linkNames): { linkNames: linkNames },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withShortFields':: d.fn(help='"shortFields defines whether to use short fields in the message layout.\\nWhen true, fields may be displayed side by side to save space."', args=[d.arg(name='shortFields', type=d.T.boolean)]),
        withShortFields(shortFields): { shortFields: shortFields },
        '#withText':: d.fn(help='"text defines the message text to send.\\nThis is optional because attachments can be used instead of or alongside text."', args=[d.arg(name='text', type=d.T.string)]),
        withText(text): { text: text },
        '#withThumbURL':: d.fn(help='"thumbURL defines the thumbnail URL for the message.\\nThis displays a small thumbnail image alongside the message content."', args=[d.arg(name='thumbURL', type=d.T.string)]),
        withThumbURL(thumbURL): { thumbURL: thumbURL },
        '#withTitle':: d.fn(help='"title defines the message title displayed prominently in the message.\\nThis appears as bold text at the top of the message attachment."', args=[d.arg(name='title', type=d.T.string)]),
        withTitle(title): { title: title },
        '#withTitleLink':: d.fn(help='"titleLink defines the URL that the title will link to when clicked.\\nThis makes the message title clickable in the RocketChat interface."', args=[d.arg(name='titleLink', type=d.T.string)]),
        withTitleLink(titleLink): { titleLink: titleLink },
      },
      '#slackConfigs':: d.obj(help='"slackConfigs defines the list of Slack configurations."'),
      slackConfigs: {
        '#actions':: d.obj(help='"actions defines a list of Slack actions that are sent with each notification."'),
        actions: {
          '#confirm':: d.obj(help='"confirm defines an optional confirmation dialog that appears before the action is executed.\\nWhen set, users must confirm their intent before the action proceeds."'),
          confirm: {
            '#withDismissText':: d.fn(help='"dismissText defines the label for the cancel button in the dialog.\\nWhen not specified, defaults to \\"Cancel\\". This button cancels the action."', args=[d.arg(name='dismissText', type=d.T.string)]),
            withDismissText(dismissText): { confirm+: { dismissText: dismissText } },
            '#withOkText':: d.fn(help='"okText defines the label for the confirmation button in the dialog.\\nWhen not specified, defaults to \\"Okay\\". This button proceeds with the action."', args=[d.arg(name='okText', type=d.T.string)]),
            withOkText(okText): { confirm+: { okText: okText } },
            '#withText':: d.fn(help='"text defines the main message displayed in the confirmation dialog.\\nThis should be a clear question or statement asking the user to confirm their action."', args=[d.arg(name='text', type=d.T.string)]),
            withText(text): { confirm+: { text: text } },
            '#withTitle':: d.fn(help='"title defines the title text displayed at the top of the confirmation dialog.\\nWhen not specified, a default title will be used."', args=[d.arg(name='title', type=d.T.string)]),
            withTitle(title): { confirm+: { title: title } },
          },
          '#withName':: d.fn(help='"name defines a unique identifier for the action within the message.\\nThis value is sent back to your application when the action is triggered."', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { name: name },
          '#withStyle':: d.fn(help='"style defines the visual appearance of the action element.\\nValid values include \\"default\\", \\"primary\\" (green), and \\"danger\\" (red)."', args=[d.arg(name='style', type=d.T.string)]),
          withStyle(style): { style: style },
          '#withText':: d.fn(help='"text defines the user-visible label displayed on the action element.\\nFor buttons, this is the button text. For select menus, this is the placeholder text."', args=[d.arg(name='text', type=d.T.string)]),
          withText(text): { text: text },
          '#withType':: d.fn(help='"type defines the type of interactive component.\\nCommon values include \\"button\\" for clickable buttons and \\"select\\" for dropdown menus."', args=[d.arg(name='type', type=d.T.string)]),
          withType(type): { type: type },
          '#withUrl':: d.fn(help='"url defines the URL to open when the action is triggered.\\nOnly applicable for button-type actions. When set, clicking the button opens this URL."', args=[d.arg(name='url', type=d.T.string)]),
          withUrl(url): { url: url },
          '#withValue':: d.fn(help='"value defines the payload sent when the action is triggered.\\nThis data is included in the callback sent to your application."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#apiURL':: d.obj(help="\"apiURL defines the secret's key that contains the Slack webhook URL.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
        apiURL: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { apiURL+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { apiURL+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { apiURL+: { optional: optional } },
        },
        '#fields':: d.obj(help='"fields defines a list of Slack fields that are sent with each notification."'),
        fields: {
          '#withShort':: d.fn(help='"short determines whether this field can be displayed alongside other short fields.\\nWhen true, Slack may display this field side by side with other short fields.\\nWhen false or not specified, the field takes the full width of the message."', args=[d.arg(name='short', type=d.T.boolean)]),
          withShort(short): { short: short },
          '#withTitle':: d.fn(help='"title defines the label or header text displayed for this field.\\nThis appears as bold text above the field value in the Slack message."', args=[d.arg(name='title', type=d.T.string)]),
          withTitle(title): { title: title },
          '#withValue':: d.fn(help='"value defines the content or data displayed for this field.\\nThis appears below the title and can contain plain text or Slack markdown."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#httpConfig':: d.obj(help='"httpConfig defines the HTTP client configuration."'),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#withActions':: d.fn(help='"actions defines a list of Slack actions that are sent with each notification."', args=[d.arg(name='actions', type=d.T.array)]),
        withActions(actions): { actions: if std.isArray(v=actions) then actions else [actions] },
        '#withActionsMixin':: d.fn(help='"actions defines a list of Slack actions that are sent with each notification."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='actions', type=d.T.array)]),
        withActionsMixin(actions): { actions+: if std.isArray(v=actions) then actions else [actions] },
        '#withCallbackId':: d.fn(help='"callbackId defines an identifier for the message used in interactive components."', args=[d.arg(name='callbackId', type=d.T.string)]),
        withCallbackId(callbackId): { callbackId: callbackId },
        '#withChannel':: d.fn(help='"channel defines the channel or user to send notifications to."', args=[d.arg(name='channel', type=d.T.string)]),
        withChannel(channel): { channel: channel },
        '#withColor':: d.fn(help='"color defines the color of the left border of the Slack message attachment.\\nCan be a hex color code (e.g., \\"#ff0000\\") or a predefined color name."', args=[d.arg(name='color', type=d.T.string)]),
        withColor(color): { color: color },
        '#withFallback':: d.fn(help="\"fallback defines a plain-text summary of the attachment for clients that don't support attachments.\"", args=[d.arg(name='fallback', type=d.T.string)]),
        withFallback(fallback): { fallback: fallback },
        '#withFields':: d.fn(help='"fields defines a list of Slack fields that are sent with each notification."', args=[d.arg(name='fields', type=d.T.array)]),
        withFields(fields): { fields: if std.isArray(v=fields) then fields else [fields] },
        '#withFieldsMixin':: d.fn(help='"fields defines a list of Slack fields that are sent with each notification."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='fields', type=d.T.array)]),
        withFieldsMixin(fields): { fields+: if std.isArray(v=fields) then fields else [fields] },
        '#withFooter':: d.fn(help='"footer defines small text displayed at the bottom of the message attachment."', args=[d.arg(name='footer', type=d.T.string)]),
        withFooter(footer): { footer: footer },
        '#withIconEmoji':: d.fn(help="\"iconEmoji defines the emoji to use as the bot's avatar (e.g., \\\":ghost:\\\").\"", args=[d.arg(name='iconEmoji', type=d.T.string)]),
        withIconEmoji(iconEmoji): { iconEmoji: iconEmoji },
        '#withIconURL':: d.fn(help="\"iconURL defines the URL to an image to use as the bot's avatar.\"", args=[d.arg(name='iconURL', type=d.T.string)]),
        withIconURL(iconURL): { iconURL: iconURL },
        '#withImageURL':: d.fn(help='"imageURL defines the URL to an image file that will be displayed inside the message attachment."', args=[d.arg(name='imageURL', type=d.T.string)]),
        withImageURL(imageURL): { imageURL: imageURL },
        '#withLinkNames':: d.fn(help='"linkNames enables automatic linking of channel names and usernames in the message.\\nWhen true, @channel and @username will be converted to clickable links."', args=[d.arg(name='linkNames', type=d.T.boolean)]),
        withLinkNames(linkNames): { linkNames: linkNames },
        '#withMrkdwnIn':: d.fn(help='"mrkdwnIn defines which fields should be parsed as Slack markdown.\\nValid values include \\"pretext\\", \\"text\\", and \\"fields\\"."', args=[d.arg(name='mrkdwnIn', type=d.T.array)]),
        withMrkdwnIn(mrkdwnIn): { mrkdwnIn: if std.isArray(v=mrkdwnIn) then mrkdwnIn else [mrkdwnIn] },
        '#withMrkdwnInMixin':: d.fn(help='"mrkdwnIn defines which fields should be parsed as Slack markdown.\\nValid values include \\"pretext\\", \\"text\\", and \\"fields\\"."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='mrkdwnIn', type=d.T.array)]),
        withMrkdwnInMixin(mrkdwnIn): { mrkdwnIn+: if std.isArray(v=mrkdwnIn) then mrkdwnIn else [mrkdwnIn] },
        '#withPretext':: d.fn(help='"pretext defines optional text that appears above the message attachment block."', args=[d.arg(name='pretext', type=d.T.string)]),
        withPretext(pretext): { pretext: pretext },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withShortFields':: d.fn(help='"shortFields determines whether fields are displayed in a compact format.\\nWhen true, fields are shown side by side when possible."', args=[d.arg(name='shortFields', type=d.T.boolean)]),
        withShortFields(shortFields): { shortFields: shortFields },
        '#withText':: d.fn(help='"text defines the main text content of the Slack message attachment."', args=[d.arg(name='text', type=d.T.string)]),
        withText(text): { text: text },
        '#withThumbURL':: d.fn(help='"thumbURL defines the URL to an image file that will be displayed as a thumbnail\\non the right side of the message attachment."', args=[d.arg(name='thumbURL', type=d.T.string)]),
        withThumbURL(thumbURL): { thumbURL: thumbURL },
        '#withTitle':: d.fn(help='"title defines the title text displayed in the Slack message attachment."', args=[d.arg(name='title', type=d.T.string)]),
        withTitle(title): { title: title },
        '#withTitleLink':: d.fn(help='"titleLink defines the URL that the title will link to when clicked."', args=[d.arg(name='titleLink', type=d.T.string)]),
        withTitleLink(titleLink): { titleLink: titleLink },
        '#withUsername':: d.fn(help='"username defines the slack bot user name."', args=[d.arg(name='username', type=d.T.string)]),
        withUsername(username): { username: username },
      },
      '#snsConfigs':: d.obj(help='"snsConfigs defines the list of SNS configurations"'),
      snsConfigs: {
        '#httpConfig':: d.obj(help='"httpConfig defines the HTTP client configuration for SNS API requests."'),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#sigv4':: d.obj(help="\"sigv4 configures AWS's Signature Verification 4 signing process to sign requests.\\nThis includes AWS credentials and region configuration for authentication.\""),
        sigv4: {
          '#accessKey':: d.obj(help='"accessKey defines the AWS API key. If not specified, the environment variable\\n`AWS_ACCESS_KEY_ID` is used."'),
          accessKey: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { sigv4+: { accessKey+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { sigv4+: { accessKey+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { sigv4+: { accessKey+: { optional: optional } } },
          },
          '#secretKey':: d.obj(help='"secretKey defines the AWS API secret. If not specified, the environment\\nvariable `AWS_SECRET_ACCESS_KEY` is used."'),
          secretKey: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { sigv4+: { secretKey+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { sigv4+: { secretKey+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { sigv4+: { secretKey+: { optional: optional } } },
          },
          '#withProfile':: d.fn(help='"profile defines the named AWS profile used to authenticate."', args=[d.arg(name='profile', type=d.T.string)]),
          withProfile(profile): { sigv4+: { profile: profile } },
          '#withRegion':: d.fn(help='"region defines the AWS region. If blank, the region from the default credentials chain used."', args=[d.arg(name='region', type=d.T.string)]),
          withRegion(region): { sigv4+: { region: region } },
          '#withRoleArn':: d.fn(help='"roleArn defines the named AWS profile used to authenticate."', args=[d.arg(name='roleArn', type=d.T.string)]),
          withRoleArn(roleArn): { sigv4+: { roleArn: roleArn } },
          '#withUseFIPSSTSEndpoint':: d.fn(help='"useFIPSSTSEndpoint defines FIPS mode for AWS STS endpoint.\\nIt requires Prometheus >= v2.54.0."', args=[d.arg(name='useFIPSSTSEndpoint', type=d.T.boolean)]),
          withUseFIPSSTSEndpoint(useFIPSSTSEndpoint): { sigv4+: { useFIPSSTSEndpoint: useFIPSSTSEndpoint } },
        },
        '#withApiURL':: d.fn(help='"apiURL defines the SNS API URL, e.g. https://sns.us-east-2.amazonaws.com.\\nIf not specified, the SNS API URL from the SNS SDK will be used."', args=[d.arg(name='apiURL', type=d.T.string)]),
        withApiURL(apiURL): { apiURL: apiURL },
        '#withAttributes':: d.fn(help='"attributes defines SNS message attributes as key-value pairs.\\nThese provide additional metadata that can be used for message filtering and routing."', args=[d.arg(name='attributes', type=d.T.object)]),
        withAttributes(attributes): { attributes: attributes },
        '#withAttributesMixin':: d.fn(help='"attributes defines SNS message attributes as key-value pairs.\\nThese provide additional metadata that can be used for message filtering and routing."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='attributes', type=d.T.object)]),
        withAttributesMixin(attributes): { attributes+: attributes },
        '#withMessage':: d.fn(help='"message defines the message content of the SNS notification.\\nThis is the actual notification text that will be sent to subscribers."', args=[d.arg(name='message', type=d.T.string)]),
        withMessage(message): { message: message },
        '#withPhoneNumber':: d.fn(help="\"phoneNumber defines the phone number if message is delivered via SMS in E.164 format.\\nIf you don't specify this value, you must specify a value for the TopicARN or TargetARN.\"", args=[d.arg(name='phoneNumber', type=d.T.string)]),
        withPhoneNumber(phoneNumber): { phoneNumber: phoneNumber },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withSubject':: d.fn(help='"subject defines the subject line when the message is delivered to email endpoints.\\nThis field is only used when sending to email subscribers of an SNS topic."', args=[d.arg(name='subject', type=d.T.string)]),
        withSubject(subject): { subject: subject },
        '#withTargetARN':: d.fn(help="\"targetARN defines the mobile platform endpoint ARN if message is delivered via mobile notifications.\\nIf you don't specify this value, you must specify a value for the TopicARN or PhoneNumber.\"", args=[d.arg(name='targetARN', type=d.T.string)]),
        withTargetARN(targetARN): { targetARN: targetARN },
        '#withTopicARN':: d.fn(help="\"topicARN defines the SNS topic ARN, e.g. arn:aws:sns:us-east-2:698519295917:My-Topic.\\nIf you don't specify this value, you must specify a value for the PhoneNumber or TargetARN.\"", args=[d.arg(name='topicARN', type=d.T.string)]),
        withTopicARN(topicARN): { topicARN: topicARN },
      },
      '#telegramConfigs':: d.obj(help='"telegramConfigs defines the list of Telegram configurations."'),
      telegramConfigs: {
        '#botToken':: d.obj(help='"botToken defines the Telegram bot token. It is mutually exclusive with `botTokenFile`.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\\nEither `botToken` or `botTokenFile` is required."'),
        botToken: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { botToken+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { botToken+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { botToken+: { optional: optional } },
        },
        '#httpConfig':: d.obj(help='"httpConfig defines the HTTP client configuration for Telegram API requests."'),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#withApiURL':: d.fn(help='"apiURL defines the Telegram API URL, e.g. https://api.telegram.org.\\nIf not specified, the default Telegram API URL will be used."', args=[d.arg(name='apiURL', type=d.T.string)]),
        withApiURL(apiURL): { apiURL: apiURL },
        '#withBotTokenFile':: d.fn(help='"botTokenFile defines the file to read the Telegram bot token from.\\nIt is mutually exclusive with `botToken`.\\nEither `botToken` or `botTokenFile` is required.\\nIt requires Alertmanager >= v0.26.0."', args=[d.arg(name='botTokenFile', type=d.T.string)]),
        withBotTokenFile(botTokenFile): { botTokenFile: botTokenFile },
        '#withChatID':: d.fn(help='"chatID defines the Telegram chat ID where messages will be sent.\\nThis can be a user ID, group ID, or channel ID (with @ prefix for public channels)."', args=[d.arg(name='chatID', type=d.T.integer)]),
        withChatID(chatID): { chatID: chatID },
        '#withDisableNotifications':: d.fn(help='"disableNotifications controls whether Telegram notifications are sent silently.\\nWhen true, users will receive the message without notification sounds."', args=[d.arg(name='disableNotifications', type=d.T.boolean)]),
        withDisableNotifications(disableNotifications): { disableNotifications: disableNotifications },
        '#withMessage':: d.fn(help='"message defines the message template for the Telegram notification.\\nThis is the content that will be sent to the specified chat."', args=[d.arg(name='message', type=d.T.string)]),
        withMessage(message): { message: message },
        '#withMessageThreadID':: d.fn(help='"messageThreadID defines the Telegram Group Topic ID for threaded messages.\\nThis allows sending messages to specific topics within Telegram groups.\\nIt requires Alertmanager >= 0.26.0."', args=[d.arg(name='messageThreadID', type=d.T.integer)]),
        withMessageThreadID(messageThreadID): { messageThreadID: messageThreadID },
        '#withParseMode':: d.fn(help='"parseMode defines the parse mode for telegram message formatting.\\nValid values are \\"MarkdownV2\\", \\"Markdown\\", and \\"HTML\\".\\nThis determines how text formatting is interpreted in the message."', args=[d.arg(name='parseMode', type=d.T.string)]),
        withParseMode(parseMode): { parseMode: parseMode },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
      },
      '#victoropsConfigs':: d.obj(help='"victoropsConfigs defines the list of VictorOps configurations."'),
      victoropsConfigs: {
        '#apiKey':: d.obj(help="\"apiKey defines the secret's key that contains the API key to use when talking to the VictorOps API.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
        apiKey: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { apiKey+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { apiKey+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { apiKey+: { optional: optional } },
        },
        '#customFields':: d.obj(help='"customFields defines additional custom fields for notification.\\nThese provide extra metadata that will be included with the VictorOps incident."'),
        customFields: {
          '#withKey':: d.fn(help='"key defines the key of the tuple.\\nThis is the identifier or name part of the key-value pair."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { key: key },
          '#withValue':: d.fn(help='"value defines the value of the tuple.\\nThis is the data or content associated with the key."', args=[d.arg(name='value', type=d.T.string)]),
          withValue(value): { value: value },
        },
        '#httpConfig':: d.obj(help="\"httpConfig defines the HTTP client's configuration for VictorOps API requests.\""),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#withApiUrl':: d.fn(help='"apiUrl defines the VictorOps API URL.\\nWhen not specified, defaults to the standard VictorOps API endpoint."', args=[d.arg(name='apiUrl', type=d.T.string)]),
        withApiUrl(apiUrl): { apiUrl: apiUrl },
        '#withCustomFields':: d.fn(help='"customFields defines additional custom fields for notification.\\nThese provide extra metadata that will be included with the VictorOps incident."', args=[d.arg(name='customFields', type=d.T.array)]),
        withCustomFields(customFields): { customFields: if std.isArray(v=customFields) then customFields else [customFields] },
        '#withCustomFieldsMixin':: d.fn(help='"customFields defines additional custom fields for notification.\\nThese provide extra metadata that will be included with the VictorOps incident."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='customFields', type=d.T.array)]),
        withCustomFieldsMixin(customFields): { customFields+: if std.isArray(v=customFields) then customFields else [customFields] },
        '#withEntityDisplayName':: d.fn(help='"entityDisplayName contains a summary of the alerted problem.\\nThis appears as the main title or identifier for the incident."', args=[d.arg(name='entityDisplayName', type=d.T.string)]),
        withEntityDisplayName(entityDisplayName): { entityDisplayName: entityDisplayName },
        '#withMessageType':: d.fn(help='"messageType describes the behavior of the alert.\\nValid values are \\"CRITICAL\\", \\"WARNING\\", and \\"INFO\\"."', args=[d.arg(name='messageType', type=d.T.string)]),
        withMessageType(messageType): { messageType: messageType },
        '#withMonitoringTool':: d.fn(help='"monitoringTool defines the monitoring tool the state message is from.\\nThis helps identify the source system that generated the alert."', args=[d.arg(name='monitoringTool', type=d.T.string)]),
        withMonitoringTool(monitoringTool): { monitoringTool: monitoringTool },
        '#withRoutingKey':: d.fn(help='"routingKey defines a key used to map the alert to a team.\\nThis determines which VictorOps team will receive the alert notification."', args=[d.arg(name='routingKey', type=d.T.string)]),
        withRoutingKey(routingKey): { routingKey: routingKey },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withStateMessage':: d.fn(help='"stateMessage contains a long explanation of the alerted problem.\\nThis provides detailed context about the incident."', args=[d.arg(name='stateMessage', type=d.T.string)]),
        withStateMessage(stateMessage): { stateMessage: stateMessage },
      },
      '#webexConfigs':: d.obj(help='"webexConfigs defines the list of Webex configurations."'),
      webexConfigs: {
        '#httpConfig':: d.obj(help="\"httpConfig defines the HTTP client's configuration.\""),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#withApiURL':: d.fn(help='"apiURL defines the Webex Teams API URL i.e. https://webexapis.com/v1/messages"', args=[d.arg(name='apiURL', type=d.T.string)]),
        withApiURL(apiURL): { apiURL: apiURL },
        '#withMessage':: d.fn(help='"message defines the message template"', args=[d.arg(name='message', type=d.T.string)]),
        withMessage(message): { message: message },
        '#withRoomID':: d.fn(help='"roomID defines the ID of the Webex Teams room where to send the messages."', args=[d.arg(name='roomID', type=d.T.string)]),
        withRoomID(roomID): { roomID: roomID },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
      },
      '#webhookConfigs':: d.obj(help='"webhookConfigs defines the List of webhook configurations."'),
      webhookConfigs: {
        '#httpConfig':: d.obj(help='"httpConfig defines the HTTP client configuration for webhook requests."'),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#urlSecret':: d.obj(help="\"urlSecret defines the secret's key that contains the webhook URL to send HTTP requests to.\\nurlSecret takes precedence over url. One of urlSecret and url should be defined.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
        urlSecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { urlSecret+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { urlSecret+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { urlSecret+: { optional: optional } },
        },
        '#withMaxAlerts':: d.fn(help='"maxAlerts defines the maximum number of alerts to be sent per webhook message.\\nWhen 0, all alerts are included in the webhook payload."', args=[d.arg(name='maxAlerts', type=d.T.integer)]),
        withMaxAlerts(maxAlerts): { maxAlerts: maxAlerts },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withTimeout':: d.fn(help='"timeout defines the maximum time to wait for a webhook request to complete,\\nbefore failing the request and allowing it to be retried.\\nIt requires Alertmanager >= v0.28.0."', args=[d.arg(name='timeout', type=d.T.string)]),
        withTimeout(timeout): { timeout: timeout },
        '#withUrl':: d.fn(help='"url defines the URL to send HTTP POST requests to.\\nurlSecret takes precedence over url. One of urlSecret and url should be defined."', args=[d.arg(name='url', type=d.T.string)]),
        withUrl(url): { url: url },
      },
      '#wechatConfigs':: d.obj(help='"wechatConfigs defines the list of WeChat configurations."'),
      wechatConfigs: {
        '#apiSecret':: d.obj(help="\"apiSecret defines the secret's key that contains the WeChat API key.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
        apiSecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { apiSecret+: { key: key } },
          '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { apiSecret+: { name: name } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { apiSecret+: { optional: optional } },
        },
        '#httpConfig':: d.obj(help='"httpConfig defines the HTTP client configuration for WeChat API requests."'),
        httpConfig: {
          '#authorization':: d.obj(help='"authorization defines the authorization header configuration for the client.\\nThis is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+."'),
          authorization: {
            '#credentials':: d.obj(help='"credentials defines a key of a Secret in the namespace that contains the credentials for authentication."'),
            credentials: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { authorization+: { credentials+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { authorization+: { credentials+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { authorization+: { credentials+: { optional: optional } } } },
            },
            '#withType':: d.fn(help='"type defines the authentication type. The value is case-insensitive.\\n\\n\\"Basic\\" is not a supported value.\\n\\nDefault: \\"Bearer\\', args=[d.arg(name='type', type=d.T.string)]),
            withType(type): { httpConfig+: { authorization+: { type: type } } },
          },
          '#basicAuth':: d.obj(help='"basicAuth defines the basic authentication credentials for the client.\\nThis is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence."'),
          basicAuth: {
            '#password':: d.obj(help='"password defines a key of a Secret containing the password for\\nauthentication."'),
            password: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { password+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { password+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { password+: { optional: optional } } } },
            },
            '#username':: d.obj(help='"username defines a key of a Secret containing the username for\\nauthentication."'),
            username: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { basicAuth+: { username+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { basicAuth+: { username+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { basicAuth+: { username+: { optional: optional } } } },
            },
          },
          '#bearerTokenSecret':: d.obj(help="\"bearerTokenSecret defines the secret's key that contains the bearer token to be used by the client\\nfor authentication.\\nThe secret needs to be in the same namespace as the AlertmanagerConfig\\nobject and accessible by the Prometheus Operator.\""),
          bearerTokenSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { httpConfig+: { bearerTokenSecret+: { key: key } } },
            '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { httpConfig+: { bearerTokenSecret+: { name: name } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { httpConfig+: { bearerTokenSecret+: { optional: optional } } },
          },
          '#oauth2':: d.obj(help='"oauth2 defines the OAuth2 client credentials used to fetch a token for the targets.\\nThis enables OAuth2 authentication flow for HTTP requests."'),
          oauth2: {
            '#clientId':: d.obj(help="\"clientId defines a key of a Secret or ConfigMap containing the\\nOAuth2 client's ID.\""),
            clientId: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { clientId+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { clientId+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { clientId+: { secret+: { optional: optional } } } } },
              },
            },
            '#clientSecret':: d.obj(help="\"clientSecret defines a key of a Secret containing the OAuth2\\nclient's secret.\""),
            clientSecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { oauth2+: { clientSecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { oauth2+: { clientSecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { oauth2+: { clientSecret+: { optional: optional } } } },
            },
            '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration to use when connecting to the OAuth2 server.\\nIt requires Prometheus >= v2.43.0."'),
            tlsConfig: {
              '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
              ca: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } } },
                },
              },
              '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
              cert: {
                '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
                configMap: {
                  '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } } },
                },
                '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
                secret: {
                  '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                  withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { key: key } } } } } },
                  '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                  withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { name: name } } } } } },
                  '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                  withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } } },
                },
              },
              '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
              keySecret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { oauth2+: { tlsConfig+: { keySecret+: { optional: optional } } } } },
              },
              '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
              withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { oauth2+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } } },
              '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
              withMaxVersion(maxVersion): { httpConfig+: { oauth2+: { tlsConfig+: { maxVersion: maxVersion } } } },
              '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
              withMinVersion(minVersion): { httpConfig+: { oauth2+: { tlsConfig+: { minVersion: minVersion } } } },
              '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
              withServerName(serverName): { httpConfig+: { oauth2+: { tlsConfig+: { serverName: serverName } } } },
            },
            '#withEndpointParams':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParams(endpointParams): { httpConfig+: { oauth2+: { endpointParams: endpointParams } } },
            '#withEndpointParamsMixin':: d.fn(help='"endpointParams configures the HTTP parameters to append to the token\\nURL."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.object)]),
            withEndpointParamsMixin(endpointParams): { httpConfig+: { oauth2+: { endpointParams+: endpointParams } } },
            '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
            withNoProxy(noProxy): { httpConfig+: { oauth2+: { noProxy: noProxy } } },
            '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader: proxyConnectHeader } } },
            '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
            withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { oauth2+: { proxyConnectHeader+: proxyConnectHeader } } },
            '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
            withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { oauth2+: { proxyFromEnvironment: proxyFromEnvironment } } },
            '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
            withProxyUrl(proxyUrl): { httpConfig+: { oauth2+: { proxyUrl: proxyUrl } } },
            '#withScopes':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopes(scopes): { httpConfig+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withScopesMixin':: d.fn(help='"scopes defines the OAuth2 scopes used for the token request."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
            withScopesMixin(scopes): { httpConfig+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } },
            '#withTokenUrl':: d.fn(help='"tokenUrl defines the URL to fetch the token from."', args=[d.arg(name='tokenUrl', type=d.T.string)]),
            withTokenUrl(tokenUrl): { httpConfig+: { oauth2+: { tokenUrl: tokenUrl } } },
          },
          '#tlsConfig':: d.obj(help='"tlsConfig defines the TLS configuration for the client.\\nThis includes settings for certificates, CA validation, and TLS protocol options."'),
          tlsConfig: {
            '#ca':: d.obj(help='"ca defines the Certificate authority used when verifying server certificates."'),
            ca: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { ca+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { ca+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { ca+: { secret+: { optional: optional } } } } },
              },
            },
            '#cert':: d.obj(help='"cert defines the Client certificate to present when doing client-authentication."'),
            cert: {
              '#configMap':: d.obj(help='"configMap defines the ConfigMap containing data to use for the targets."'),
              configMap: {
                '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { configMap+: { optional: optional } } } } },
              },
              '#secret':: d.obj(help='"secret defines the Secret containing data to use for the targets."'),
              secret: {
                '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
                withKey(key): { httpConfig+: { tlsConfig+: { cert+: { secret+: { key: key } } } } },
                '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
                withName(name): { httpConfig+: { tlsConfig+: { cert+: { secret+: { name: name } } } } },
                '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
                withOptional(optional): { httpConfig+: { tlsConfig+: { cert+: { secret+: { optional: optional } } } } },
              },
            },
            '#keySecret':: d.obj(help='"keySecret defines the Secret containing the client key file for the targets."'),
            keySecret: {
              '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
              withKey(key): { httpConfig+: { tlsConfig+: { keySecret+: { key: key } } } },
              '#withName':: d.fn(help='"Name of the referent.\\nThis field is effectively required, but due to backwards compatibility is\\nallowed to be empty. Instances of this type with an empty value here are\\nalmost certainly wrong.\\nMore info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
              withName(name): { httpConfig+: { tlsConfig+: { keySecret+: { name: name } } } },
              '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
              withOptional(optional): { httpConfig+: { tlsConfig+: { keySecret+: { optional: optional } } } },
            },
            '#withInsecureSkipVerify':: d.fn(help='"insecureSkipVerify defines how to disable target certificate validation."', args=[d.arg(name='insecureSkipVerify', type=d.T.boolean)]),
            withInsecureSkipVerify(insecureSkipVerify): { httpConfig+: { tlsConfig+: { insecureSkipVerify: insecureSkipVerify } } },
            '#withMaxVersion':: d.fn(help='"maxVersion defines the maximum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.41.0 or Thanos >= v0.31.0."', args=[d.arg(name='maxVersion', type=d.T.string)]),
            withMaxVersion(maxVersion): { httpConfig+: { tlsConfig+: { maxVersion: maxVersion } } },
            '#withMinVersion':: d.fn(help='"minVersion defines the minimum acceptable TLS version.\\n\\nIt requires Prometheus >= v2.35.0 or Thanos >= v0.28.0."', args=[d.arg(name='minVersion', type=d.T.string)]),
            withMinVersion(minVersion): { httpConfig+: { tlsConfig+: { minVersion: minVersion } } },
            '#withServerName':: d.fn(help='"serverName is used to verify the hostname for the targets."', args=[d.arg(name='serverName', type=d.T.string)]),
            withServerName(serverName): { httpConfig+: { tlsConfig+: { serverName: serverName } } },
          },
          '#withEnableHttp2':: d.fn(help='"enableHttp2 can be used to disable HTTP2."', args=[d.arg(name='enableHttp2', type=d.T.boolean)]),
          withEnableHttp2(enableHttp2): { httpConfig+: { enableHttp2: enableHttp2 } },
          '#withFollowRedirects':: d.fn(help='"followRedirects specifies whether the client should follow HTTP 3xx redirects.\\nWhen true, the client will automatically follow redirect responses."', args=[d.arg(name='followRedirects', type=d.T.boolean)]),
          withFollowRedirects(followRedirects): { httpConfig+: { followRedirects: followRedirects } },
          '#withNoProxy':: d.fn(help='"noProxy defines a comma-separated string that can contain IPs, CIDR notation, domain names\\nthat should be excluded from proxying. IP and domain names can\\ncontain port numbers.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='noProxy', type=d.T.string)]),
          withNoProxy(noProxy): { httpConfig+: { noProxy: noProxy } },
          '#withProxyConnectHeader':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeader(proxyConnectHeader): { httpConfig+: { proxyConnectHeader: proxyConnectHeader } },
          '#withProxyConnectHeaderMixin':: d.fn(help='"proxyConnectHeader optionally specifies headers to send to\\nproxies during CONNECT requests.\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='proxyConnectHeader', type=d.T.object)]),
          withProxyConnectHeaderMixin(proxyConnectHeader): { httpConfig+: { proxyConnectHeader+: proxyConnectHeader } },
          '#withProxyFromEnvironment':: d.fn(help='"proxyFromEnvironment defines whether to use the proxy configuration defined by environment variables (HTTP_PROXY, HTTPS_PROXY, and NO_PROXY).\\n\\nIt requires Prometheus >= v2.43.0, Alertmanager >= v0.25.0 or Thanos >= v0.32.0."', args=[d.arg(name='proxyFromEnvironment', type=d.T.boolean)]),
          withProxyFromEnvironment(proxyFromEnvironment): { httpConfig+: { proxyFromEnvironment: proxyFromEnvironment } },
          '#withProxyURL':: d.fn(help='"proxyURL defines an optional proxy URL for HTTP requests.\\nIf defined, this field takes precedence over `proxyUrl`."', args=[d.arg(name='proxyURL', type=d.T.string)]),
          withProxyURL(proxyURL): { httpConfig+: { proxyURL: proxyURL } },
          '#withProxyUrl':: d.fn(help='"proxyUrl defines the HTTP proxy server to use."', args=[d.arg(name='proxyUrl', type=d.T.string)]),
          withProxyUrl(proxyUrl): { httpConfig+: { proxyUrl: proxyUrl } },
        },
        '#withAgentID':: d.fn(help='"agentID defines the application agent ID within WeChat Work.\\nThis identifies which WeChat Work application will send the notifications."', args=[d.arg(name='agentID', type=d.T.string)]),
        withAgentID(agentID): { agentID: agentID },
        '#withApiURL':: d.fn(help='"apiURL defines the WeChat API URL.\\nWhen not specified, defaults to the standard WeChat Work API endpoint."', args=[d.arg(name='apiURL', type=d.T.string)]),
        withApiURL(apiURL): { apiURL: apiURL },
        '#withCorpID':: d.fn(help='"corpID defines the corp id for authentication.\\nThis is the unique identifier for your WeChat Work organization."', args=[d.arg(name='corpID', type=d.T.string)]),
        withCorpID(corpID): { corpID: corpID },
        '#withMessage':: d.fn(help='"message defines the API request data as defined by the WeChat API.\\nThis contains the actual notification content to be sent."', args=[d.arg(name='message', type=d.T.string)]),
        withMessage(message): { message: message },
        '#withMessageType':: d.fn(help='"messageType defines the type of message to send.\\nValid values include \\"text\\", \\"markdown\\", and other WeChat Work supported message types."', args=[d.arg(name='messageType', type=d.T.string)]),
        withMessageType(messageType): { messageType: messageType },
        '#withSendResolved':: d.fn(help='"sendResolved defines whether or not to notify about resolved alerts."', args=[d.arg(name='sendResolved', type=d.T.boolean)]),
        withSendResolved(sendResolved): { sendResolved: sendResolved },
        '#withToParty':: d.fn(help="\"toParty defines the target department(s) to receive the notification.\\nCan be a single department ID or multiple department IDs separated by '|'.\"", args=[d.arg(name='toParty', type=d.T.string)]),
        withToParty(toParty): { toParty: toParty },
        '#withToTag':: d.fn(help="\"toTag defines the target tag(s) to receive the notification.\\nCan be a single tag ID or multiple tag IDs separated by '|'.\"", args=[d.arg(name='toTag', type=d.T.string)]),
        withToTag(toTag): { toTag: toTag },
        '#withToUser':: d.fn(help="\"toUser defines the target user(s) to receive the notification.\\nCan be a single user ID or multiple user IDs separated by '|'.\"", args=[d.arg(name='toUser', type=d.T.string)]),
        withToUser(toUser): { toUser: toUser },
      },
      '#withDiscordConfigs':: d.fn(help='"discordConfigs defines the list of Slack configurations."', args=[d.arg(name='discordConfigs', type=d.T.array)]),
      withDiscordConfigs(discordConfigs): { discordConfigs: if std.isArray(v=discordConfigs) then discordConfigs else [discordConfigs] },
      '#withDiscordConfigsMixin':: d.fn(help='"discordConfigs defines the list of Slack configurations."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='discordConfigs', type=d.T.array)]),
      withDiscordConfigsMixin(discordConfigs): { discordConfigs+: if std.isArray(v=discordConfigs) then discordConfigs else [discordConfigs] },
      '#withEmailConfigs':: d.fn(help='"emailConfigs defines the list of Email configurations."', args=[d.arg(name='emailConfigs', type=d.T.array)]),
      withEmailConfigs(emailConfigs): { emailConfigs: if std.isArray(v=emailConfigs) then emailConfigs else [emailConfigs] },
      '#withEmailConfigsMixin':: d.fn(help='"emailConfigs defines the list of Email configurations."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='emailConfigs', type=d.T.array)]),
      withEmailConfigsMixin(emailConfigs): { emailConfigs+: if std.isArray(v=emailConfigs) then emailConfigs else [emailConfigs] },
      '#withMsteamsConfigs':: d.fn(help='"msteamsConfigs defines the list of MSTeams configurations.\\nIt requires Alertmanager >= 0.26.0."', args=[d.arg(name='msteamsConfigs', type=d.T.array)]),
      withMsteamsConfigs(msteamsConfigs): { msteamsConfigs: if std.isArray(v=msteamsConfigs) then msteamsConfigs else [msteamsConfigs] },
      '#withMsteamsConfigsMixin':: d.fn(help='"msteamsConfigs defines the list of MSTeams configurations.\\nIt requires Alertmanager >= 0.26.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='msteamsConfigs', type=d.T.array)]),
      withMsteamsConfigsMixin(msteamsConfigs): { msteamsConfigs+: if std.isArray(v=msteamsConfigs) then msteamsConfigs else [msteamsConfigs] },
      '#withMsteamsv2Configs':: d.fn(help='"msteamsv2Configs defines the list of MSTeamsV2 configurations.\\nIt requires Alertmanager >= 0.28.0."', args=[d.arg(name='msteamsv2Configs', type=d.T.array)]),
      withMsteamsv2Configs(msteamsv2Configs): { msteamsv2Configs: if std.isArray(v=msteamsv2Configs) then msteamsv2Configs else [msteamsv2Configs] },
      '#withMsteamsv2ConfigsMixin':: d.fn(help='"msteamsv2Configs defines the list of MSTeamsV2 configurations.\\nIt requires Alertmanager >= 0.28.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='msteamsv2Configs', type=d.T.array)]),
      withMsteamsv2ConfigsMixin(msteamsv2Configs): { msteamsv2Configs+: if std.isArray(v=msteamsv2Configs) then msteamsv2Configs else [msteamsv2Configs] },
      '#withName':: d.fn(help='"name defines the name of the receiver. Must be unique across all items from the list."', args=[d.arg(name='name', type=d.T.string)]),
      withName(name): { name: name },
      '#withOpsgenieConfigs':: d.fn(help='"opsgenieConfigs defines the list of OpsGenie configurations."', args=[d.arg(name='opsgenieConfigs', type=d.T.array)]),
      withOpsgenieConfigs(opsgenieConfigs): { opsgenieConfigs: if std.isArray(v=opsgenieConfigs) then opsgenieConfigs else [opsgenieConfigs] },
      '#withOpsgenieConfigsMixin':: d.fn(help='"opsgenieConfigs defines the list of OpsGenie configurations."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='opsgenieConfigs', type=d.T.array)]),
      withOpsgenieConfigsMixin(opsgenieConfigs): { opsgenieConfigs+: if std.isArray(v=opsgenieConfigs) then opsgenieConfigs else [opsgenieConfigs] },
      '#withPagerdutyConfigs':: d.fn(help='"pagerdutyConfigs defines the List of PagerDuty configurations."', args=[d.arg(name='pagerdutyConfigs', type=d.T.array)]),
      withPagerdutyConfigs(pagerdutyConfigs): { pagerdutyConfigs: if std.isArray(v=pagerdutyConfigs) then pagerdutyConfigs else [pagerdutyConfigs] },
      '#withPagerdutyConfigsMixin':: d.fn(help='"pagerdutyConfigs defines the List of PagerDuty configurations."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='pagerdutyConfigs', type=d.T.array)]),
      withPagerdutyConfigsMixin(pagerdutyConfigs): { pagerdutyConfigs+: if std.isArray(v=pagerdutyConfigs) then pagerdutyConfigs else [pagerdutyConfigs] },
      '#withPushoverConfigs':: d.fn(help='"pushoverConfigs defines the list of Pushover configurations."', args=[d.arg(name='pushoverConfigs', type=d.T.array)]),
      withPushoverConfigs(pushoverConfigs): { pushoverConfigs: if std.isArray(v=pushoverConfigs) then pushoverConfigs else [pushoverConfigs] },
      '#withPushoverConfigsMixin':: d.fn(help='"pushoverConfigs defines the list of Pushover configurations."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='pushoverConfigs', type=d.T.array)]),
      withPushoverConfigsMixin(pushoverConfigs): { pushoverConfigs+: if std.isArray(v=pushoverConfigs) then pushoverConfigs else [pushoverConfigs] },
      '#withRocketchatConfigs':: d.fn(help='"rocketchatConfigs defines the list of RocketChat configurations.\\nIt requires Alertmanager >= 0.28.0."', args=[d.arg(name='rocketchatConfigs', type=d.T.array)]),
      withRocketchatConfigs(rocketchatConfigs): { rocketchatConfigs: if std.isArray(v=rocketchatConfigs) then rocketchatConfigs else [rocketchatConfigs] },
      '#withRocketchatConfigsMixin':: d.fn(help='"rocketchatConfigs defines the list of RocketChat configurations.\\nIt requires Alertmanager >= 0.28.0."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='rocketchatConfigs', type=d.T.array)]),
      withRocketchatConfigsMixin(rocketchatConfigs): { rocketchatConfigs+: if std.isArray(v=rocketchatConfigs) then rocketchatConfigs else [rocketchatConfigs] },
      '#withSlackConfigs':: d.fn(help='"slackConfigs defines the list of Slack configurations."', args=[d.arg(name='slackConfigs', type=d.T.array)]),
      withSlackConfigs(slackConfigs): { slackConfigs: if std.isArray(v=slackConfigs) then slackConfigs else [slackConfigs] },
      '#withSlackConfigsMixin':: d.fn(help='"slackConfigs defines the list of Slack configurations."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='slackConfigs', type=d.T.array)]),
      withSlackConfigsMixin(slackConfigs): { slackConfigs+: if std.isArray(v=slackConfigs) then slackConfigs else [slackConfigs] },
      '#withSnsConfigs':: d.fn(help='"snsConfigs defines the list of SNS configurations"', args=[d.arg(name='snsConfigs', type=d.T.array)]),
      withSnsConfigs(snsConfigs): { snsConfigs: if std.isArray(v=snsConfigs) then snsConfigs else [snsConfigs] },
      '#withSnsConfigsMixin':: d.fn(help='"snsConfigs defines the list of SNS configurations"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='snsConfigs', type=d.T.array)]),
      withSnsConfigsMixin(snsConfigs): { snsConfigs+: if std.isArray(v=snsConfigs) then snsConfigs else [snsConfigs] },
      '#withTelegramConfigs':: d.fn(help='"telegramConfigs defines the list of Telegram configurations."', args=[d.arg(name='telegramConfigs', type=d.T.array)]),
      withTelegramConfigs(telegramConfigs): { telegramConfigs: if std.isArray(v=telegramConfigs) then telegramConfigs else [telegramConfigs] },
      '#withTelegramConfigsMixin':: d.fn(help='"telegramConfigs defines the list of Telegram configurations."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='telegramConfigs', type=d.T.array)]),
      withTelegramConfigsMixin(telegramConfigs): { telegramConfigs+: if std.isArray(v=telegramConfigs) then telegramConfigs else [telegramConfigs] },
      '#withVictoropsConfigs':: d.fn(help='"victoropsConfigs defines the list of VictorOps configurations."', args=[d.arg(name='victoropsConfigs', type=d.T.array)]),
      withVictoropsConfigs(victoropsConfigs): { victoropsConfigs: if std.isArray(v=victoropsConfigs) then victoropsConfigs else [victoropsConfigs] },
      '#withVictoropsConfigsMixin':: d.fn(help='"victoropsConfigs defines the list of VictorOps configurations."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='victoropsConfigs', type=d.T.array)]),
      withVictoropsConfigsMixin(victoropsConfigs): { victoropsConfigs+: if std.isArray(v=victoropsConfigs) then victoropsConfigs else [victoropsConfigs] },
      '#withWebexConfigs':: d.fn(help='"webexConfigs defines the list of Webex configurations."', args=[d.arg(name='webexConfigs', type=d.T.array)]),
      withWebexConfigs(webexConfigs): { webexConfigs: if std.isArray(v=webexConfigs) then webexConfigs else [webexConfigs] },
      '#withWebexConfigsMixin':: d.fn(help='"webexConfigs defines the list of Webex configurations."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='webexConfigs', type=d.T.array)]),
      withWebexConfigsMixin(webexConfigs): { webexConfigs+: if std.isArray(v=webexConfigs) then webexConfigs else [webexConfigs] },
      '#withWebhookConfigs':: d.fn(help='"webhookConfigs defines the List of webhook configurations."', args=[d.arg(name='webhookConfigs', type=d.T.array)]),
      withWebhookConfigs(webhookConfigs): { webhookConfigs: if std.isArray(v=webhookConfigs) then webhookConfigs else [webhookConfigs] },
      '#withWebhookConfigsMixin':: d.fn(help='"webhookConfigs defines the List of webhook configurations."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='webhookConfigs', type=d.T.array)]),
      withWebhookConfigsMixin(webhookConfigs): { webhookConfigs+: if std.isArray(v=webhookConfigs) then webhookConfigs else [webhookConfigs] },
      '#withWechatConfigs':: d.fn(help='"wechatConfigs defines the list of WeChat configurations."', args=[d.arg(name='wechatConfigs', type=d.T.array)]),
      withWechatConfigs(wechatConfigs): { wechatConfigs: if std.isArray(v=wechatConfigs) then wechatConfigs else [wechatConfigs] },
      '#withWechatConfigsMixin':: d.fn(help='"wechatConfigs defines the list of WeChat configurations."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='wechatConfigs', type=d.T.array)]),
      withWechatConfigsMixin(wechatConfigs): { wechatConfigs+: if std.isArray(v=wechatConfigs) then wechatConfigs else [wechatConfigs] },
    },
    '#route':: d.obj(help="\"route defines the Alertmanager route definition for alerts matching the resource's\\nnamespace. If present, it will be added to the generated Alertmanager\\nconfiguration as a first-level route.\""),
    route: {
      '#matchers':: d.obj(help="\"matchers defines the list of matchers that the alert's labels should match. For the first\\nlevel route, the operator removes any existing equality and regexp\\nmatcher on the `namespace` label and adds a `namespace: \u003cobject\\nnamespace\u003e` matcher.\""),
      matchers: {
        '#withMatchType':: d.fn(help='"matchType defines the match operation available with AlertManager >= v0.22.0.\\nTakes precedence over Regex (deprecated) if non-empty.\\nValid values: \\"=\\" (equality), \\"!=\\" (inequality), \\"=~\\" (regex match), \\"!~\\" (regex non-match)."', args=[d.arg(name='matchType', type=d.T.string)]),
        withMatchType(matchType): { matchType: matchType },
        '#withName':: d.fn(help='"name defines the label to match.\\nThis specifies which alert label should be evaluated."', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { name: name },
        '#withRegex':: d.fn(help='"regex defines whether to match on equality (false) or regular-expression (true).\\nDeprecated: for AlertManager >= v0.22.0, `matchType` should be used instead."', args=[d.arg(name='regex', type=d.T.boolean)]),
        withRegex(regex): { regex: regex },
        '#withValue':: d.fn(help='"value defines the label value to match.\\nThis is the expected value for the specified label."', args=[d.arg(name='value', type=d.T.string)]),
        withValue(value): { value: value },
      },
      '#withActiveTimeIntervals':: d.fn(help='"activeTimeIntervals is a list of MuteTimeInterval names when this route should be active."', args=[d.arg(name='activeTimeIntervals', type=d.T.array)]),
      withActiveTimeIntervals(activeTimeIntervals): { spec+: { route+: { activeTimeIntervals: if std.isArray(v=activeTimeIntervals) then activeTimeIntervals else [activeTimeIntervals] } } },
      '#withActiveTimeIntervalsMixin':: d.fn(help='"activeTimeIntervals is a list of MuteTimeInterval names when this route should be active."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='activeTimeIntervals', type=d.T.array)]),
      withActiveTimeIntervalsMixin(activeTimeIntervals): { spec+: { route+: { activeTimeIntervals+: if std.isArray(v=activeTimeIntervals) then activeTimeIntervals else [activeTimeIntervals] } } },
      '#withContinue':: d.fn(help='"continue defines the boolean indicating whether an alert should continue matching subsequent\\nsibling nodes. It will always be overridden to true for the first-level\\nroute by the Prometheus operator."', args=[d.arg(name='continue', type=d.T.boolean)]),
      withContinue(continue): { spec+: { route+: { continue: continue } } },
      '#withGroupBy':: d.fn(help='"groupBy defines the list of labels to group by.\\nLabels must not be repeated (unique list).\\nSpecial label \\"...\\" (aggregate by all possible labels), if provided, must be the only element in the list."', args=[d.arg(name='groupBy', type=d.T.array)]),
      withGroupBy(groupBy): { spec+: { route+: { groupBy: if std.isArray(v=groupBy) then groupBy else [groupBy] } } },
      '#withGroupByMixin':: d.fn(help='"groupBy defines the list of labels to group by.\\nLabels must not be repeated (unique list).\\nSpecial label \\"...\\" (aggregate by all possible labels), if provided, must be the only element in the list."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='groupBy', type=d.T.array)]),
      withGroupByMixin(groupBy): { spec+: { route+: { groupBy+: if std.isArray(v=groupBy) then groupBy else [groupBy] } } },
      '#withGroupInterval':: d.fn(help='"groupInterval defines how long to wait before sending an updated notification.\\nMust match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`\\nExample: \\"5m\\', args=[d.arg(name='groupInterval', type=d.T.string)]),
      withGroupInterval(groupInterval): { spec+: { route+: { groupInterval: groupInterval } } },
      '#withGroupWait':: d.fn(help='"groupWait defines how long to wait before sending the initial notification.\\nMust match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`\\nExample: \\"30s\\', args=[d.arg(name='groupWait', type=d.T.string)]),
      withGroupWait(groupWait): { spec+: { route+: { groupWait: groupWait } } },
      '#withMatchers':: d.fn(help="\"matchers defines the list of matchers that the alert's labels should match. For the first\\nlevel route, the operator removes any existing equality and regexp\\nmatcher on the `namespace` label and adds a `namespace: \u003cobject\\nnamespace\u003e` matcher.\"", args=[d.arg(name='matchers', type=d.T.array)]),
      withMatchers(matchers): { spec+: { route+: { matchers: if std.isArray(v=matchers) then matchers else [matchers] } } },
      '#withMatchersMixin':: d.fn(help="\"matchers defines the list of matchers that the alert's labels should match. For the first\\nlevel route, the operator removes any existing equality and regexp\\nmatcher on the `namespace` label and adds a `namespace: \u003cobject\\nnamespace\u003e` matcher.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='matchers', type=d.T.array)]),
      withMatchersMixin(matchers): { spec+: { route+: { matchers+: if std.isArray(v=matchers) then matchers else [matchers] } } },
      '#withMuteTimeIntervals':: d.fn(help='"muteTimeIntervals is a list of MuteTimeInterval names that will mute this route when matched,"', args=[d.arg(name='muteTimeIntervals', type=d.T.array)]),
      withMuteTimeIntervals(muteTimeIntervals): { spec+: { route+: { muteTimeIntervals: if std.isArray(v=muteTimeIntervals) then muteTimeIntervals else [muteTimeIntervals] } } },
      '#withMuteTimeIntervalsMixin':: d.fn(help='"muteTimeIntervals is a list of MuteTimeInterval names that will mute this route when matched,"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='muteTimeIntervals', type=d.T.array)]),
      withMuteTimeIntervalsMixin(muteTimeIntervals): { spec+: { route+: { muteTimeIntervals+: if std.isArray(v=muteTimeIntervals) then muteTimeIntervals else [muteTimeIntervals] } } },
      '#withReceiver':: d.fn(help='"receiver defines the name of the receiver for this route. If not empty, it should be listed in\\nthe `receivers` field."', args=[d.arg(name='receiver', type=d.T.string)]),
      withReceiver(receiver): { spec+: { route+: { receiver: receiver } } },
      '#withRepeatInterval':: d.fn(help='"repeatInterval defines how long to wait before repeating the last notification.\\nMust match the regular expression`^(([0-9]+)y)?(([0-9]+)w)?(([0-9]+)d)?(([0-9]+)h)?(([0-9]+)m)?(([0-9]+)s)?(([0-9]+)ms)?$`\\nExample: \\"4h\\', args=[d.arg(name='repeatInterval', type=d.T.string)]),
      withRepeatInterval(repeatInterval): { spec+: { route+: { repeatInterval: repeatInterval } } },
      '#withRoutes':: d.fn(help='"routes defines the child routes."', args=[d.arg(name='routes', type=d.T.array)]),
      withRoutes(routes): { spec+: { route+: { routes: if std.isArray(v=routes) then routes else [routes] } } },
      '#withRoutesMixin':: d.fn(help='"routes defines the child routes."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='routes', type=d.T.array)]),
      withRoutesMixin(routes): { spec+: { route+: { routes+: if std.isArray(v=routes) then routes else [routes] } } },
    },
    '#withInhibitRules':: d.fn(help="\"inhibitRules defines the list of inhibition rules. The rules will only apply to alerts matching\\nthe resource's namespace.\"", args=[d.arg(name='inhibitRules', type=d.T.array)]),
    withInhibitRules(inhibitRules): { spec+: { inhibitRules: if std.isArray(v=inhibitRules) then inhibitRules else [inhibitRules] } },
    '#withInhibitRulesMixin':: d.fn(help="\"inhibitRules defines the list of inhibition rules. The rules will only apply to alerts matching\\nthe resource's namespace.\"\n\n**Note:** This function appends passed data to existing values", args=[d.arg(name='inhibitRules', type=d.T.array)]),
    withInhibitRulesMixin(inhibitRules): { spec+: { inhibitRules+: if std.isArray(v=inhibitRules) then inhibitRules else [inhibitRules] } },
    '#withMuteTimeIntervals':: d.fn(help='"muteTimeIntervals defines the list of MuteTimeInterval specifying when the routes should be muted."', args=[d.arg(name='muteTimeIntervals', type=d.T.array)]),
    withMuteTimeIntervals(muteTimeIntervals): { spec+: { muteTimeIntervals: if std.isArray(v=muteTimeIntervals) then muteTimeIntervals else [muteTimeIntervals] } },
    '#withMuteTimeIntervalsMixin':: d.fn(help='"muteTimeIntervals defines the list of MuteTimeInterval specifying when the routes should be muted."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='muteTimeIntervals', type=d.T.array)]),
    withMuteTimeIntervalsMixin(muteTimeIntervals): { spec+: { muteTimeIntervals+: if std.isArray(v=muteTimeIntervals) then muteTimeIntervals else [muteTimeIntervals] } },
    '#withReceivers':: d.fn(help='"receivers defines the list of receivers."', args=[d.arg(name='receivers', type=d.T.array)]),
    withReceivers(receivers): { spec+: { receivers: if std.isArray(v=receivers) then receivers else [receivers] } },
    '#withReceiversMixin':: d.fn(help='"receivers defines the list of receivers."\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='receivers', type=d.T.array)]),
    withReceiversMixin(receivers): { spec+: { receivers+: if std.isArray(v=receivers) then receivers else [receivers] } },
  },
  '#mixin': 'ignore',
  mixin: self,
}
